{"title":"Effective Modern C++[A4]","uid":11532986,"size":23789282,"categoryP":"other","categoryS":"e_books","magnet":"?xt=urn:btih:d170a00ae910eb44c61100f72c2a9b7f3da0d856&amp;dn=Effective+Modern+C%2B%2B%5BA4%5D&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337&amp;tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&amp;tr=udp%3A%2F%2Fexodus.desync.com%3A6969","seeders":15,"leechers":1,"uploader":"AUDI-A4","files":2,"time":1416592837,"description":"Chapter 1Deducing Types\nItem 1:Ã¢â‚¬â€šUnderstand template type deduction.\nItem 2:Ã¢â‚¬â€šUnderstand auto type deduction.\nItem 3:Ã¢â‚¬â€šUnderstand decltype.\nItem 4:Ã¢â‚¬â€šKnow how to view deduced types.\nChapter 2auto\nItem 5:Ã¢â‚¬â€šPrefer auto to explicit type declarations.\nItem 6:Ã¢â‚¬â€šUse the explicitly typed initializer idiom when auto deduces undesired types.\nChapter 3Moving to Modern C++\nItem 7:Ã¢â‚¬â€šDistinguish between () and {} when creating objects.\nItem 8: Prefer nullptr to 0 and NULL.\nItem 9:Ã¢â‚¬â€šPrefer alias declarations to typedefs.\nItem 10:Ã¢â‚¬â€šPrefer scoped enums to unscoped enums.\nItem 11:Ã¢â‚¬â€šPrefer deleted functions to private undefined ones.\nItem 12:Ã¢â‚¬â€šDeclare overriding functions override.\nItem 13:Ã¢â‚¬â€šPrefer const_iterators to iterators.\nItem 14:Ã¢â‚¬â€šDeclare functions noexcept if they wonÃ¢â‚¬â„¢t emit exceptions.\nItem 15:Ã¢â‚¬â€šUse constexpr whenever possible.\nItem 16:Ã¢â‚¬â€šMake const member functions thread safe.\nItem 17:Ã¢â‚¬â€šUnderstand special member function generation.\nChapter 4Smart Pointers\nItem 18:Ã¢â‚¬â€šUse std::unique_ptr for exclusive-ownership resource management.\nItem 19:Ã¢â‚¬â€šUse std::shared_ptr for shared-ownership resource management.\nItem 20:Ã¢â‚¬â€šUse std::weak_ptr for std::shared_ptr-like pointers that can dangle.\nItem 21:Ã¢â‚¬â€šPrefer std::make_unique and std::make_shared to direct use of new.\nItem 22:Ã¢â‚¬â€šWhen using the Pimpl Idiom, define special member functions in the implementation file.\nChapter 5Rvalue References, Move Semantics, and Perfect Forwarding\nItem 23:Ã¢â‚¬â€šUnderstand std::move and std::forward.\nItem 24:Ã¢â‚¬â€šDistinguish universal references from rvalue references.\nItem 25:Ã¢â‚¬â€šUse std::move on rvalue references, std::forward on universal references.\nItem 26:Ã¢â‚¬â€šAvoid overloading on universal references.\nItem 27:Ã¢â‚¬â€šFamiliarize yourself with alternatives to overloading on universal references.\nItem 28:Ã¢â‚¬â€šUnderstand reference collapsing.\nItem 29:Ã¢â‚¬â€šAssume that move operations are not present, not cheap, and not used.\nItem 30:Ã¢â‚¬â€šFamiliarize yourself with perfect forwarding failure cases.\nChapter 7Lambda Expressions\nItem 31:Ã¢â‚¬â€šAvoid default capture modes.\nItem 32:Ã¢â‚¬â€šUse init capture to move objects into closures.\nItem 33:Ã¢â‚¬â€šUse decltype on auto&amp;&amp; parameters to std::forward them.\nItem 34:Ã¢â‚¬â€šPrefer lambdas to std::bind.\nChapter 8The Concurrency API\nItem 35:Ã¢â‚¬â€šPrefer task-based programming to thread-based.\nItem 36:Ã¢â‚¬â€šSpecify std::launch::async if asynchronicity is essential.\nItem 37:Ã¢â‚¬â€šMake std::threads unjoinable on all paths.\nItem 38:Ã¢â‚¬â€šBe aware of varying thread handle destructor behavior.\nItem 39:Ã¢â‚¬â€šConsider void futures for one-shot event communication.\nItem 40:Ã¢â‚¬â€šUse std::atomic for concurrency, volatile for special memory.\nChapter 9Tweaks\nItem 41:Ã¢â‚¬â€šConsider pass by value for copyable parameters that are cheap to move and always copied.\nItem 42:Ã¢â‚¬â€šConsider emplacement instead of insertion","torrent":{"xt":"urn:btih:d170a00ae910eb44c61100f72c2a9b7f3da0d856","amp;dn":"Effective+Modern+C%2B%2B%5BA4%5D","amp;tr":["udp%3A%2F%2Ftracker.openbittorrent.com%3A80","udp%3A%2F%2Fopen.demonii.com%3A1337","udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969","udp%3A%2F%2Fexodus.desync.com%3A6969"],"infoHash":"d170a00ae910eb44c61100f72c2a9b7f3da0d856","infoHashBuffer":{"type":"Buffer","data":[209,112,160,10,233,16,235,68,198,17,0,247,44,42,155,127,61,160,216,86]},"announce":[],"urlList":[]}}